import { ParsedTranslations } from './parser.js';
import { parseMessageParams, InterpolationSyntax } from '@typeglot/core';

/**
 * Options for code generation
 */
export interface GeneratorOptions {
  interpolation?: InterpolationSyntax;
}

/**
 * Get the regex pattern string for the formatMessage function based on interpolation syntax
 */
function getFormatMessageRegex(interpolation: InterpolationSyntax): string {
  return interpolation === 'double' ? '/\\{\\{(\\w+)\\}\\}/g' : '/\\{(\\w+)\\}/g';
}

/**
 * Get the fallback placeholder for unmatched params
 */
function getFallbackPlaceholder(interpolation: InterpolationSyntax): string {
  return interpolation === 'double' ? '`{{${key}}}`' : '`{${key}}`';
}

/**
 * Generate TypeScript functions for all translation keys
 */
export function generateTypedFunctions(
  translations: ParsedTranslations,
  locale: string,
  options: GeneratorOptions = {}
): string {
  const interpolation = options.interpolation ?? 'single';
  const lines: string[] = [
    '// Auto-generated by @typeglot/compiler',
    '// Do not edit manually',
    '',
    "import type { Locale } from './index.js';",
    '',
    `let currentLocale: Locale = '${locale}';`,
    'let messages: Record<string, string> = {};',
    '',
    '/**',
    ' * Set the current locale',
    ' */',
    'export function setLocale(locale: Locale): void {',
    '  currentLocale = locale;',
    '}',
    '',
    '/**',
    ' * Get the current locale',
    ' */',
    'export function getLocale(): Locale {',
    '  return currentLocale;',
    '}',
    '',
    '/**',
    ' * Load messages for a locale',
    ' */',
    'export function loadMessages(localeMessages: Record<string, string>): void {',
    '  messages = localeMessages;',
    '}',
    '',
    '/**',
    ' * Format a message with parameters',
    ' */',
    'function formatMessage(template: string, params: Record<string, string | number>): string {',
    `  return template.replace(${getFormatMessageRegex(interpolation)}, (_, key) => {`,
    '    const value = params[key];',
    `    return value !== undefined ? String(value) : ${getFallbackPlaceholder(interpolation)};`,
    '  });',
    '}',
    '',
  ];

  // Generate a function for each translation key
  for (const [key, value] of Object.entries(translations)) {
    const params = parseMessageParams(value, interpolation);
    const functionCode = generateKeyFunction(key, value, params);
    lines.push(functionCode);
  }

  // Generate the main messages object
  lines.push('/**');
  lines.push(' * All typed translation functions');
  lines.push(' */');
  lines.push('export const m = {');

  for (const key of Object.keys(translations)) {
    lines.push(`  ${sanitizeIdentifier(key)},`);
  }

  lines.push('} as const;');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate a typed function for a single translation key
 */
function generateKeyFunction(
  key: string,
  defaultValue: string,
  params: { name: string; type: 'string' | 'number' }[]
): string {
  const funcName = sanitizeIdentifier(key);
  const escapedDefault = defaultValue.replace(/`/g, '\\`').replace(/\$/g, '\\$');

  if (params.length === 0) {
    // No parameters - simple getter
    return [
      `/**`,
      ` * @default "${defaultValue.replace(/"/g, '\\"')}"`,
      ` */`,
      `export function ${funcName}(): string {`,
      `  return messages['${key}'] ?? \`${escapedDefault}\`;`,
      `}`,
      '',
    ].join('\n');
  }

  // Has parameters - function with typed params object
  const paramType = params
    .map((p) => `${p.name}: ${p.type === 'number' ? 'number' : 'string'}`)
    .join('; ');

  return [
    `/**`,
    ` * @default "${defaultValue.replace(/"/g, '\\"')}"`,
    ` */`,
    `export function ${funcName}(params: { ${paramType} }): string {`,
    `  const template = messages['${key}'] ?? \`${escapedDefault}\`;`,
    `  return formatMessage(template, params);`,
    `}`,
    '',
  ].join('\n');
}

/**
 * Convert a translation key to a valid TypeScript identifier
 */
function sanitizeIdentifier(key: string): string {
  // Replace dots and special chars with underscores
  let identifier = key.replace(/[^a-zA-Z0-9_]/g, '_');

  // Ensure it doesn't start with a number
  if (/^[0-9]/.test(identifier)) {
    identifier = '_' + identifier;
  }

  return identifier;
}
