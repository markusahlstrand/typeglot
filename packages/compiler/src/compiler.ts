import * as fs from 'node:fs';
import * as path from 'node:path';
import { TypeGlotConfig } from '@typeglot/core';
import { parseTranslationFile, ParsedTranslations } from './parser.js';
import { generateTypedFunctions } from './generator.js';

export interface CompileResult {
  success: boolean;
  outputPath: string;
  keysCount: number;
  errors?: string[];
}

export interface CompilerOptions {
  config: TypeGlotConfig;
  projectRoot: string;
  verbose?: boolean;
}

/**
 * Main compiler class for TypeGlot
 */
export class TypeGlotCompiler {
  private config: TypeGlotConfig;
  private projectRoot: string;
  private verbose: boolean;

  constructor(options: CompilerOptions) {
    this.config = options.config;
    this.projectRoot = options.projectRoot;
    this.verbose = options.verbose ?? false;
  }

  /**
   * Compile all translation files to TypeScript
   */
  async compile(): Promise<CompileResult[]> {
    const results: CompileResult[] = [];
    const localesDir = path.resolve(this.projectRoot, this.config.localesDir);

    // Ensure output directory exists
    const outputDir = path.resolve(this.projectRoot, this.config.outputDir);
    await fs.promises.mkdir(outputDir, { recursive: true });

    // Find all locale files
    const files = await this.getLocaleFiles(localesDir);

    if (files.length === 0) {
      this.log('No translation files found');
      return results;
    }

    // Parse the source locale first
    const sourceFile = files.find((f) => this.getLocaleFromPath(f) === this.config.sourceLocale);

    if (!sourceFile) {
      return [
        {
          success: false,
          outputPath: '',
          keysCount: 0,
          errors: [`Source locale file not found: ${this.config.sourceLocale}.json`],
        },
      ];
    }

    const sourceTranslations = await parseTranslationFile(sourceFile);

    // Generate the main messages module
    const mainOutput = await this.generateMainModule(sourceTranslations, outputDir);
    results.push(mainOutput);

    // Generate locale-specific modules
    for (const file of files) {
      const locale = this.getLocaleFromPath(file);
      const translations = await parseTranslationFile(file);
      const result = await this.generateLocaleModule(locale, translations, outputDir);
      results.push(result);
    }

    // Generate index file
    await this.generateIndexFile(files, outputDir);

    return results;
  }

  /**
   * Compile a single locale file
   */
  async compileSingle(filePath: string): Promise<CompileResult> {
    const locale = this.getLocaleFromPath(filePath);
    const translations = await parseTranslationFile(filePath);
    const outputDir = path.resolve(this.projectRoot, this.config.outputDir);

    return this.generateLocaleModule(locale, translations, outputDir);
  }

  private async generateMainModule(
    translations: ParsedTranslations,
    outputDir: string
  ): Promise<CompileResult> {
    const outputPath = path.join(outputDir, 'messages.ts');
    const code = generateTypedFunctions(translations, this.config.sourceLocale);

    await fs.promises.writeFile(outputPath, code, 'utf-8');

    this.log(`Generated: ${outputPath} (${Object.keys(translations).length} keys)`);

    return {
      success: true,
      outputPath,
      keysCount: Object.keys(translations).length,
    };
  }

  private async generateLocaleModule(
    locale: string,
    translations: ParsedTranslations,
    outputDir: string
  ): Promise<CompileResult> {
    const outputPath = path.join(outputDir, `${locale}.ts`);
    const code = this.generateLocaleData(locale, translations);

    await fs.promises.writeFile(outputPath, code, 'utf-8');

    this.log(`Generated: ${outputPath} (${Object.keys(translations).length} keys)`);

    return {
      success: true,
      outputPath,
      keysCount: Object.keys(translations).length,
    };
  }

  private generateLocaleData(locale: string, translations: ParsedTranslations): string {
    const lines: string[] = [
      '// Auto-generated by @typeglot/compiler',
      '// Do not edit manually',
      '',
      `export const locale = '${locale}' as const;`,
      '',
      'export const messages = {',
    ];

    for (const [key, value] of Object.entries(translations)) {
      const escapedValue = value.replace(/'/g, "\\'").replace(/\n/g, '\\n');
      lines.push(`  '${key}': '${escapedValue}',`);
    }

    lines.push('} as const;');
    lines.push('');
    lines.push('export type MessageKey = keyof typeof messages;');
    lines.push('');

    return lines.join('\n');
  }

  private async generateIndexFile(files: string[], outputDir: string): Promise<void> {
    const locales = files.map((f) => this.getLocaleFromPath(f));

    const lines: string[] = [
      '// Auto-generated by @typeglot/compiler',
      '// Do not edit manually',
      '',
      "export * from './messages.js';",
      '',
    ];

    for (const locale of locales) {
      lines.push(`export * as ${locale} from './${locale}.js';`);
    }

    lines.push('');
    lines.push(
      `export const availableLocales = [${locales.map((l) => `'${l}'`).join(', ')}] as const;`
    );
    lines.push('export type Locale = (typeof availableLocales)[number];');
    lines.push('');

    const outputPath = path.join(outputDir, 'index.ts');
    await fs.promises.writeFile(outputPath, lines.join('\n'), 'utf-8');

    this.log(`Generated: ${outputPath}`);
  }

  private async getLocaleFiles(localesDir: string): Promise<string[]> {
    try {
      const entries = await fs.promises.readdir(localesDir, { withFileTypes: true });
      return entries
        .filter((e) => e.isFile() && e.name.endsWith('.json'))
        .map((e) => path.join(localesDir, e.name));
    } catch {
      return [];
    }
  }

  private getLocaleFromPath(filePath: string): string {
    return path.basename(filePath, '.json');
  }

  private log(message: string): void {
    if (this.verbose) {
      console.log(`[typeglot] ${message}`);
    }
  }
}
